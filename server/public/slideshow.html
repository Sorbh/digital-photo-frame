<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Photo Frame - Slideshow</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/basecoat-css@0.3.1/dist/basecoat.cdn.min.css">
    <script src="https://cdn.jsdelivr.net/npm/basecoat-css@0.3.1/dist/js/all.min.js" defer></script>
    <link rel="stylesheet" href="css/design-system.css">
    <link rel="stylesheet" href="css/slideshow-extensions.css">
    
    <!-- Theme Switcher Script -->
    <script>
    (() => {
      try {
        const stored = localStorage.getItem('themeMode');
        if (stored ? stored === 'dark' : matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add('dark');
        }
      } catch (_) {}
      
      document.addEventListener('basecoat:theme', (e) => {
        const mode = e.detail?.mode || (document.documentElement.classList.contains('dark') ? 'light' : 'dark');
        if (mode === 'dark') {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        localStorage.setItem('themeMode', mode);
      });
    })();
    </script>
</head>

<body>
    <!-- PIN Authentication Overlay -->
    <div class="auth-overlay" id="authOverlay">
        <div class="auth-container">
            <h1 class="auth-title">Welcome</h1>
            <p class="auth-subtitle">Enter your PIN to access the photo slideshow</p>

            <form class="pin-form" id="pinForm" novalidate>
                <input type="password" id="pinInput" class="pin-input" placeholder="â€¢â€¢â€¢â€¢" maxlength="6"
                    autocomplete="off" inputmode="numeric">

                <button type="submit" class="auth-button" id="authButton">
                    <span class="material-icons">lock_open</span>
                    Access Slideshow
                </button>

                <div class="auth-error" id="authError"></div>
                <div class="auth-loading" id="authLoading">
                    <div class="spinner"></div>
                    <span>Authenticating...</span>
                </div>
            </form>
        </div>
    </div>

    <div class="slideshow-container">
        <div class="loading" id="loading">Loading your photos...</div>
        <div class="error hidden" id="error">Unable to load images. Please check your connection.</div>

        <div class="slide" id="slide1">
            <img id="image1" alt="Photo">
        </div>

        <div class="slide" id="slide2">
            <img id="image2" alt="Photo">
        </div>

        <div class="info hidden" id="info">
            <div id="filename"></div>
            <div id="folder"></div>
        </div>

        <div class="progress-bar" id="progressBar"></div>

        <div class="controls">
            <div id="folderSelector" class="folder-selector-container">
                <!-- Folder selector will be initialized here -->
            </div>
            <button class="control-btn" id="fullscreenBtn" title="Fullscreen">
                <span class="material-icons">fullscreen</span>
            </button>
            <button class="control-btn" id="logoutBtn" title="Logout">
                <span class="material-icons">logout</span>
            </button>
        </div>
    </div>

    <!-- Load folder selection scripts -->
    <script src="/js/folderService.js"></script>
    <script src="/js/folderStorage.js"></script>
    <script src="/js/folderSelector.js"></script>

    <script>
        class AuthenticationManager {
            constructor() {
                this.isAuthenticated = false;
                this.authOverlay = document.getElementById('authOverlay');
                this.pinForm = document.getElementById('pinForm');
                this.pinInput = document.getElementById('pinInput');
                this.authButton = document.getElementById('authButton');
                this.authError = document.getElementById('authError');
                this.authLoading = document.getElementById('authLoading');

                this.init();
            }

            init() {
                this.bindEvents();
                this.checkExistingSession();
            }

            bindEvents() {
                this.pinForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.authenticate();
                });

                this.pinInput.addEventListener('input', () => {
                    this.clearError();
                    this.clearErrorState();
                });

                this.pinInput.addEventListener('keypress', (e) => {
                    // Only allow numeric input
                    if (!/[0-9]/.test(e.key) && e.key !== 'Backspace' && e.key !== 'Delete' && e.key !== 'Tab') {
                        e.preventDefault();
                    }
                });
            }

            async checkExistingSession() {
                try {
                    const response = await fetch('/api/auth/session');
                    const data = await response.json();

                    if (data.authenticated) {
                        this.handleAuthSuccess(data.account);
                    } else {
                        this.showAuthOverlay();
                    }
                } catch (error) {
                    console.error('Session check failed:', error);
                    this.showAuthOverlay();
                }
            }

            async authenticate() {
                const pin = this.pinInput.value.trim();

                if (!pin) {
                    this.showError('Please enter your PIN');
                    return;
                }

                if (pin.length < 4) {
                    this.showError('PIN must be at least 4 digits');
                    return;
                }

                this.setLoading(true);

                try {
                    const response = await fetch('/api/auth/pin', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ pin })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.handleAuthSuccess(data.account);
                    } else {
                        this.handleAuthError(data.error, data.code);
                    }
                } catch (error) {
                    console.error('Authentication error:', error);
                    this.showError('Connection error. Please try again.');
                } finally {
                    this.setLoading(false);
                }
            }

            handleAuthSuccess(account) {
                this.isAuthenticated = true;
                this.userAccount = account;
                console.log('Authentication successful for account:', account.name);

                // Store auth state for the session
                sessionStorage.setItem('authenticated', 'true');
                sessionStorage.setItem('accountName', account.name);

                // Hide auth overlay
                this.hideAuthOverlay();

                // Always dispatch the authentication complete event for consistent handling
                document.dispatchEvent(new CustomEvent('authenticationComplete', {
                    detail: { account }
                }));
            }

            handleAuthError(error, errorCode) {
                this.showError(error || 'Invalid PIN');

                if (errorCode === 'RATE_LIMITED') {
                    // For rate limiting, disable the input and add different styling
                    this.pinInput.disabled = true;
                    this.pinInput.classList.add('error');
                    this.authButton.disabled = true;
                } else {
                    // For invalid PIN, just add error styling and focus input
                    this.pinInput.classList.add('error');
                    this.pinInput.focus();
                }
            }

            async logout() {
                try {
                    await fetch('/api/auth/session', { method: 'DELETE' });
                } catch (error) {
                    console.error('Logout error:', error);
                } finally {
                    this.isAuthenticated = false;
                    this.userAccount = null;
                    sessionStorage.removeItem('authenticated');
                    sessionStorage.removeItem('accountName');
                    this.showAuthOverlay();
                    this.clearForm();

                    // Stop slideshow
                    if (window.slideshow) {
                        window.slideshow.cleanup();
                    }
                }
            }

            showAuthOverlay() {
                this.authOverlay.classList.remove('hidden');
                setTimeout(() => {
                    this.pinInput.focus();
                }, 100);
            }

            hideAuthOverlay() {
                this.authOverlay.classList.add('hidden');
            }

            setLoading(loading) {
                this.authButton.disabled = loading;
                this.pinInput.disabled = loading;

                if (loading) {
                    this.authLoading.classList.add('show');
                    this.clearError();
                } else {
                    this.authLoading.classList.remove('show');
                }
            }

            showError(message) {
                this.authError.textContent = message;
                this.authError.innerHTML = `<span class="material-icons">error</span> ${message}`;
            }

            clearError() {
                this.authError.textContent = '';
            }

            clearErrorState() {
                this.pinInput.classList.remove('error');
                this.pinInput.disabled = false;
                this.authButton.disabled = false;
            }

            clearForm() {
                this.pinInput.value = '';
                this.clearError();
                this.clearErrorState();
                // Ensure form is fully re-enabled
                this.pinInput.disabled = false;
                this.authButton.disabled = false;
            }
        }

        class PhotoFrameSlideshow {
            constructor() {
                this.currentSlide = 0;
                this.isPlaying = true;
                this.interval = 15000; // 15 seconds
                this.timer = null;
                this.progressTimer = null;
                this.activityTimer = null;
                this.fullscreenTimer = null;
                this.preloadedImages = [];
                this.currentImageData = null;
                this.wakeLock = null;
                this.folderSelector = null;
                this.folderStorage = new FolderStorage();
                this.cursorHideTimer = null;

                this.initializeElements();
                this.setupEventListeners();
                // Delay folder selector initialization until after authentication
                this.setupCursorAutoHide();
                this.requestWakeLock();
                // Don't start slideshow automatically - wait for authentication
            }

            initializeElements() {
                this.slides = [
                    document.getElementById('slide1'),
                    document.getElementById('slide2')
                ];
                this.images = [
                    document.getElementById('image1'),
                    document.getElementById('image2')
                ];
                this.loading = document.getElementById('loading');
                this.error = document.getElementById('error');
                this.info = document.getElementById('info');
                this.filename = document.getElementById('filename');
                this.folder = document.getElementById('folder');
                this.progressBar = document.getElementById('progressBar');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.logoutBtn = document.getElementById('logoutBtn');
                
                // Ensure error div is hidden initially and images don't have invalid src
                console.log('ðŸ”§ Initializing: Hiding error div');
                this.error.classList.add('hidden');
                this.images.forEach(img => {
                    // Remove any src to prevent error events from empty/invalid src
                    img.removeAttribute('src');
                });
            }

            setupEventListeners() {
                this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                this.logoutBtn.addEventListener('click', () => this.logout());

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch (e.key) {
                        case 'f':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 'i':
                            e.preventDefault();
                            this.toggleInfo();
                            break;
                    }
                });

                // Touch/click to show controls temporarily
                document.addEventListener('click', () => {
                    this.showControlsTemporarily();
                });

                // Image load error handling - only show error if we're not already showing one
                this.images.forEach(img => {
                    img.addEventListener('error', () => {
                        // Only show error if error div is currently hidden (not already showing an error)
                        if (this.error.classList.contains('hidden')) {
                            console.log('Image load error for:', img.src);
                            this.showError('Failed to load image');
                        }
                    });
                });
            }

            async fetchRandomImage() {
                try {
                    const selectedFolderPath = this.folderStorage.getCurrentFolderPath();
                    const url = selectedFolderPath
                        ? `/api/images/random?folder=${encodeURIComponent(selectedFolderPath)}`
                        : '/api/images/random';

                    console.log('ðŸ” Fetching image from URL:', url);
                    console.log('ðŸ“ Selected folder path:', selectedFolderPath);

                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Failed to fetch image');
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to fetch image');
                    }

                    console.log('âœ… Fetched image from', selectedFolderPath || 'all folders', ':', data.image.folder, '/', data.image.filename);
                    return data.image;
                } catch (error) {
                    console.error('âŒ Error fetching random image:', error);
                    this.showError(`Failed to load image: ${error.message}`);
                    return null;
                }
            }

            async loadImage(imageData) {
                if (!imageData) return false;

                return new Promise((resolve) => {
                    const nextSlide = (this.currentSlide + 1) % 2;
                    const img = this.images[nextSlide];

                    const onLoad = () => {
                        img.removeEventListener('load', onLoad);
                        img.removeEventListener('error', onError);

                        // Hide any existing error messages on successful load
                        this.hideError();
                        this.currentImageData = imageData;
                        resolve(true);
                    };

                    const onError = (event) => {
                        img.removeEventListener('load', onLoad);
                        img.removeEventListener('error', onError);
                        console.error('Failed to load image:', imageData.url, 'Error:', event);
                        // Only show error message if this is the current image being loaded
                        if (this.error.classList.contains('hidden')) {
                            this.showError(`Failed to load image: ${imageData.filename}`);
                        }
                        resolve(false);
                    };

                    img.addEventListener('load', onLoad);
                    img.addEventListener('error', onError);
                    img.src = imageData.url;
                });
            }

            showImage() {
                const currentSlideEl = this.slides[this.currentSlide];
                const nextSlideEl = this.slides[(this.currentSlide + 1) % 2];

                // Switch active slide
                currentSlideEl.classList.remove('active');
                nextSlideEl.classList.add('active');

                // Update current slide index
                this.currentSlide = (this.currentSlide + 1) % 2;

                // Update info
                this.updateInfo();

                // Hide loading and error
                this.loading.classList.add('hidden');
                this.hideError();
            }

            updateInfo() {
                if (this.currentImageData) {
                    this.filename.textContent = this.currentImageData.filename;
                    this.folder.textContent = `ðŸ“ ${this.currentImageData.folder}`;
                    this.info.classList.remove('hidden');

                    // Auto-hide info after 3 seconds
                    setTimeout(() => {
                        this.info.classList.add('hidden');
                    }, 3000);
                }
            }

            async nextImage() {
                this.resetProgress();
                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                    }
                }

                if (this.isPlaying) {
                    this.scheduleNext();
                }
            }

            scheduleNext() {
                this.clearTimers();
                this.timer = setTimeout(() => this.nextImage(), this.interval);
                this.startProgress();
            }

            startProgress() {
                this.progressBar.style.width = '0%';
                let progress = 0;
                const increment = 100 / (this.interval / 100);

                this.progressTimer = setInterval(() => {
                    progress += increment;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(this.progressTimer);
                    }
                    this.progressBar.style.width = progress + '%';
                }, 100);
            }

            resetProgress() {
                this.progressBar.style.width = '0%';
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
            }

            clearTimers() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
                if (this.progressTimer) {
                    clearInterval(this.progressTimer);
                    this.progressTimer = null;
                }
            }


            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().then(() => {
                        document.body.classList.add('fullscreen');
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        document.body.classList.remove('fullscreen');
                    });
                }
            }

            toggleInfo() {
                this.info.classList.toggle('hidden');
            }

            logout() {
                if (window.authManager) {
                    window.authManager.logout();
                }
            }

            showControlsTemporarily() {
                if (document.fullscreenElement) {
                    const controls = document.querySelector('.controls');
                    controls.style.opacity = '1';
                    setTimeout(() => {
                        controls.style.opacity = '0';
                    }, 3000);
                }
            }

            showError(message) {
                console.log('Showing error:', message);
                this.error.textContent = message;
                this.error.classList.remove('hidden');
                this.loading.classList.add('hidden');
            }

            hideError() {
                console.log('Hiding error message');
                this.error.classList.add('hidden');
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock activated');

                        // Re-request wake lock when page becomes visible
                        document.addEventListener('visibilitychange', async () => {
                            if (this.wakeLock !== null && document.visibilityState === 'visible') {
                                try {
                                    this.wakeLock = await navigator.wakeLock.request('screen');
                                    console.log('Screen wake lock re-activated');
                                } catch (err) {
                                    console.error('Failed to re-activate wake lock:', err);
                                }
                            }
                        });
                    } else {
                        console.warn('Wake Lock API not supported');
                    }
                } catch (err) {
                    console.error('Failed to activate wake lock:', err);
                }

                // Additional screen saver prevention methods for Android TV and other devices
                this.initScreenSaverPrevention();
            }

            initScreenSaverPrevention() {
                // Method 1: Invisible video playing to prevent screen saver
                this.createKeepAliveVideo();

                // Method 2: Periodic user activity simulation
                this.startActivitySimulation();

                // Method 3: Fullscreen API to prevent system sleep
                this.maintainFullscreen();
            }

            createKeepAliveVideo() {
                // Create a silent, invisible video that loops to trick the system
                const video = document.createElement('video');
                video.style.position = 'absolute';
                video.style.top = '-1px';
                video.style.left = '-1px';
                video.style.width = '1px';
                video.style.height = '1px';
                video.style.opacity = '0';
                video.style.pointerEvents = 'none';
                video.muted = true;
                video.loop = true;
                video.autoplay = true;
                video.playsInline = true;

                // Create a minimal video data URL (1-second transparent video)
                video.src = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAr1tZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjc1NSBkZDBhNjEwIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNSAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcWZtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MyBiX3B5cmFtaWQ9MiBiX2FkYXB0PTEgYl9iaWFzPTAgZGlyZWN0PTEgd2VpZ2h0Yj0xIG9wZW5fZ29wPTAgd2VpZ2h0cD0yIGtleWludD0yNTAga2V5aW50X21pbj0yNSBzY2VuZWN1dD00MCBpbnRyYV9yZWZyZXNoPTAgcmNfbG9va2FoZWFkPTQwIHJjPWNyZiBtYnRyZWU9MSBjcmY9MjMuMCBxY29tcD0wLjYwIHFwbWluPTAgcXBtYXg9NjkgcXBzdGVwPTQgaXBfcmF0aW89MS4yNSBhcT0xOjEuMDAAgAAAAAxliIQAL//+9Qom+JAQAW5vbG6';

                document.body.appendChild(video);

                // Ensure video starts playing
                video.play().catch(err => {
                    console.log('Keep-alive video autoplay failed:', err);
                });

                console.log('Keep-alive video created for screen saver prevention');
            }

            startActivitySimulation() {
                // Simulate user activity every 30 seconds to prevent sleep
                this.activityTimer = setInterval(() => {
                    // Dispatch a minimal mouse move event
                    const event = new MouseEvent('mousemove', {
                        bubbles: true,
                        cancelable: true,
                        clientX: 1,
                        clientY: 1
                    });
                    document.dispatchEvent(event);

                    // Also try to re-request wake lock if it was lost
                    this.checkAndRenewWakeLock();
                }, 30000);

                console.log('Activity simulation started for screen saver prevention');
            }

            async checkAndRenewWakeLock() {
                try {
                    if ('wakeLock' in navigator && (!this.wakeLock || this.wakeLock.released)) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake lock renewed');
                    }
                } catch (err) {
                    console.log('Wake lock renewal failed:', err);
                }
            }

            maintainFullscreen() {
                // Periodically check and maintain fullscreen to prevent system sleep
                this.fullscreenTimer = setInterval(() => {
                    if (!document.fullscreenElement) {
                        // Try to enter fullscreen if not already
                        document.documentElement.requestFullscreen().catch(() => {
                            // Fullscreen failed, that's okay
                        });
                    }
                }, 60000); // Check every minute

                console.log('Fullscreen maintenance started for screen saver prevention');
            }

            releaseWakeLock() {
                if (this.wakeLock !== null) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                    console.log('Screen wake lock released');
                }
            }

            cleanup() {
                // Clean up all timers and resources
                this.clearTimers();

                if (this.activityTimer) {
                    clearInterval(this.activityTimer);
                    this.activityTimer = null;
                }

                if (this.fullscreenTimer) {
                    clearInterval(this.fullscreenTimer);
                    this.fullscreenTimer = null;
                }

                if (this.cursorHideTimer) {
                    clearTimeout(this.cursorHideTimer);
                    this.cursorHideTimer = null;
                }

                this.releaseWakeLock();
                console.log('Slideshow cleanup completed');
            }

            initializeFolderSelector() {
                const container = document.getElementById('folderSelector');
                if (container) {
                    this.folderSelector = new FolderSelector(container, {
                        onFolderChanged: (folderPath, folderName) => {
                            console.log('Folder changed in slideshow:', folderPath, folderName);
                            this.onFolderChanged(folderPath, folderName);
                        },
                        showFolderCount: true,
                        autoClose: true
                    });

                    // Clear the initially loaded folders to prevent showing all folders
                    // They will be reloaded properly after authentication check
                    this.folderSelector.folders = [];
                    this.folderSelector.renderFolders();
                }
            }

            async onFolderChanged(folderPath, folderName) {
                // Stop current slideshow
                this.clearTimers();

                // Reset progress
                this.resetProgress();

                console.log(`Slideshow switching to folder: ${folderName || 'All Folders'}`);

                // Immediately load and show image from selected folder
                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                        // Resume slideshow with new folder
                        this.scheduleNext();
                    } else {
                        this.showError('Failed to load image from selected folder');
                    }
                } else {
                    this.showError(`No images found in folder: ${folderName || 'All Folders'}`);
                }
            }

            setupCursorAutoHide() {
                const hideCursor = () => {
                    document.body.classList.add('hide-cursor');
                };

                const showCursor = () => {
                    document.body.classList.remove('hide-cursor');
                    clearTimeout(this.cursorHideTimer);
                    this.cursorHideTimer = setTimeout(hideCursor, 3000); // Hide after 3 seconds of inactivity
                };

                // Show cursor on mouse movement
                document.addEventListener('mousemove', showCursor);
                document.addEventListener('mousedown', showCursor);
                document.addEventListener('keydown', showCursor);

                // Initially hide cursor after 3 seconds
                this.cursorHideTimer = setTimeout(hideCursor, 3000);
            }

            async startSlideshow() {
                console.log('ðŸŽ¬ Starting slideshow - ensuring error is hidden');
                this.hideError(); // Ensure no error is showing when we start
                
                // Load first image
                const imageData = await this.fetchRandomImage();
                if (imageData) {
                    const loaded = await this.loadImage(imageData);
                    if (loaded) {
                        this.showImage();
                        this.scheduleNext();
                    } else {
                        this.showError('Failed to load first image');
                    }
                } else {
                    this.showError('No images available');
                }
            }
        }

        // Initialize authentication and slideshow when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize authentication first
            window.authManager = new AuthenticationManager();

            // Initialize slideshow (it will wait for authentication)
            window.slideshow = new PhotoFrameSlideshow();

            // Listen for successful authentication
            document.addEventListener('authenticationComplete', (e) => {
                console.log('Authentication complete, starting slideshow for:', e.detail.account.name);

                // Hide any existing error messages after successful authentication
                window.slideshow.hideError();
                
                // Initialize folder selector after authentication
                window.slideshow.initializeFolderSelector();

                // Add a small delay to ensure session is fully established before refreshing folders
                setTimeout(() => {
                    // Refresh folder list after authentication to get user-specific folders
                    if (window.slideshow && window.slideshow.folderSelector) {
                        console.log('Refreshing folder list for authenticated user');
                        window.slideshow.folderSelector.refresh();
                    }
                }, 500); // 500ms delay to ensure session is fully established

                window.slideshow.startSlideshow();
            });

            // Clean up when page is unloaded
            window.addEventListener('beforeunload', () => {
                window.slideshow.cleanup();
            });
        });
    </script>
</body>

</html>